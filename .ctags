--regex-c=/^(COMMENT: The reason we use [ \t] instead of \s is that \s was not working on OS X)/\1/X,XXX/

--regex-c=/^(COMMENT: Vim, C, Java, Javascript, Asm have defaults, so need no langdef, but we can extend them)/\1/X,XXX/
--regex-c=/^(COMMENT: It is possible to disable built-in tag detection if we want, piecewise, e.g.: ctags --extra=-q --c-kinds=-d)/\1/X,XXX/

--regex-vim=/^(COMMENT: ex-ctags already provides a 'map' tag)/\2/X,XXX/
--regex-vim=/[ \t]*(([nvxsoilc]*)(noremap|map))[ \t]+(<(buffer|silent|special|script|expr|unique)>[ \t]+)*([^ 	]*).*/\6 (\1)/m,mapping/
--regex-vim=/^(COMMENT: python functions)/\1/X,XXX/
--regex-vim=/^[ \t]*def[ \t]+([a-zA-Z0-9_$]+)/\1/f,function/

--regex-vim=/^(COMMENT: htag matches any *bold* text, so I don't recommend displaying these, but they may still be useful for Ctrl-})/\1/X,XXX/
--regex-vim=/\*([A-Za-z0-9_\-]+)\*/\1/h,htag/
--regex-vim=/^(COMMENT: not needed use augroup)[ \t]*au[tocmd]*[ \t]+[^[ \t]]+[ \t]+([A-Za-z0-9]+)/\1/d,autocmd/

--langmap=c:+.jpp,c:+.uc

--langmap=java:+.jpp,java:+.uc

--langmap=javascript:+.jpp,javascript:+.uc
--regex-javascript=/^(COMMENT: Some of Javascript's default patterns match null on Unrealscript files.)/\1/X,XXX/
--regex-javascript=/^[ \t]*var ([a-zA-Z_$][0-9a-zA-Z_$]*).*$/\1/v,variable/
--regex-javascript=/^[ \t]*module\.exports\.([a-zA-Z_$][0-9a-zA-Z_$]*)[ \t]*=.*$/\1/e,export/
--regex-javascript=/^(BUG: If what is assigned is a function, a later function rule also catches it!  Should we ignore functions, or he ignore 'this'?  In Coffee, he ignores '@' but not 'this'.)/\1/X,XXX/
--regex-javascript=/^[ \t]*this\.([a-zA-Z_$][0-9a-zA-Z_$]*)[ \t]*=.*$/\1/a,assigned/
--regex-javascript=/^[ \t]*([a-zA-Z_$][0-9a-zA-Z_$]*):.*$/\1/p,property/
--regex-javascript=/^(COMMENT: ctags defaults ignore functions inside anonymous functions - the following catch them but can cause duplicates!)/\1/X,XXX/
--regex-javascript=/^DISABLED: [ \t]*\<function\>[ \t]*(\<[a-zA-Z_$][0-9a-zA-Z_$]*\>)/\1/f,function/
--regex-javascript=/^(COMMENT: The following matches functions missed by default, those defined as A.B.f=...  Oh these are now showing up!  Eh I really don't get the pattern.  ctags seems to be catching Project.statics.markDelete just fine on its own, but not ProjectProvider.prototype.findMyProjects!)/\1/X,XXX/
--regex-javascript=/^DISABLED: [ \t]*([a-zA-Z_$][0-9a-zA-Z_$]*\.[a-zA-Z_$][0-9a-zA-Z_$]*\.[a-zA-Z_$][0-9a-zA-Z_$.]*)*[ \t]*=[ \t]*\<function\>/\1/f,function/
--regex-javascript=/^(COMMENT: However, it's worth extracting a tag just for *the last part*, for Ctrl-] in Vim, if not for viewing.)/\1/X,XXX/
--regex-javascript=/[ \t]*[a-zA-Z_$][0-9a-zA-Z_$]*\.prototype.([a-zA-Z_$][0-9a-zA-Z_$.]*)*[ \t]*=[ \t]*\<function\>/\1/h,classmethod/
--regex-javascript=/^(COMMENT: This catches class methods in JS generated by CS.  But very little else is caught there (due to the wrapper).  We cannot call these methods, because ctags automatically finds functions in property declarations and calls them methods.  Remove this if it's produces unwanted tags.)/\1/X,XXX/
--regex-javascript=/[ \t]*([a-zA-Z_$][0-9a-zA-Z_$]*)\.prototype.([a-zA-Z_$][0-9a-zA-Z_$.]*)*[ \t]*=[ \t]*\<function\>/\1::\2/M,classmethod/
--regex-javascript=/[ \t]*[a-zA-Z_$][0-9a-zA-Z_$]*\.[^p][^r][^o][^t][0-9a-zA-Z_$]*\.([a-zA-Z_$][0-9a-zA-Z_$.]*)*[ \t]*=[ \t]*\<function\>/\1/_,deep_function/
--regex-javascript=/^(COMMENT: But functions assigned to a location with 3 or more dots are not ...)/\1/X,XXX/
--regex-javascript=/^[ \t]*(([a-zA-Z_$][0-9a-zA-Z_$]*\.){3,}[a-zA-Z_$][0-9a-zA-Z_$]*)*[ \t]*=[ \t]*\<function\>/\1/f,function/
--regex-javascript=/^(COMMENT: The following matches functions missed by default, those defined as properties - this assumes you are not already using the 'property' rule above)/\1/X,XXX/
--regex-javascript=/^[ \t]*["']?([a-zA-Z_$][0-9a-zA-Z_$]*)["']?[ \t]*:[ \t]*function\>/\1/f,function/
--regex-javascript=/^(COMMENT: It used to be:)/\1/X,XXX/
--regex-javascript=/^DISABLED: [ \t]*(\<[a-zA-Z_$][0-9a-zA-Z_$.]*\>)*[ \t]*=[ \t]*\<function\>/\1/f,function/
--regex-javascript=/^(COMMENT: The following should be synced with Coffeescript definitions)/\1/X,XXX/
--regex-javascript=/^(COMMENT: Express routes: (only if var app is used))/\1/X,XXX/
--regex-javascript=/^[ \t]*app\.(get|put|post|delete)\([ \t]*["']([^"']+)["']/\2 (\1)/r,route/
--regex-javascript=/^(COMMENT: Meteor routes (with iron:router):)/\1/X,XXX/
--regex-javascript=/^[ \t]*this\.route\([ \t]*["']([^"']*)["']/\1/r,route/
--regex-javascript=/^[ \t]*Meteor.publish\([ \t]*["']([^"']*)["']/\1/u,publication/
--regex-javascript=/^(COMMENT: Backbone router: (if var router is used))/\1/X,XXX/
--regex-javascript=/^[ \t]*router\.on[ \t]*\([ \t]*["']route:([^"']*)["']/\1/r,route/
--regex-javascript=/^(COMMENT: Anything assigned from the start of a line)/\1/X,XXX/
--regex-javascript=/^([a-zA-Z_$][0-9a-zA-Z_$.]*)[ \t]*=/\1/f,function/

--langdef=opa
--langmap=opa:+.opa
--regex-opa=/^[ \t]*\<type\>[ \t]*(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)/\1/t,type/
--regex-opa=/^[ \t]*\<database\>[ \t]*(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)/\1/d,database/
--regex-opa=/^[ \t]*\<module\>[ \t]*(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)/\1/m,module/
--regex-opa=/^(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)[ \t]*=/\1/g,global/
--regex-opa=/^([ \t]*client|[ \t]*server|[ \t]*)[ \t]*\<function\>[ \t]*(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)/\2/f,function/

--langdef=man
--langmap=man:+.~,man:+.man
--regex-man=/^(COMMENT: I can't seem to get the ~ extension to match.)/\1/s,section/
--regex-man=/^([A-Z].*)/\1/s,section/

--langdef=uc
--langmap=uc:+.jpp,uc:+.uc
--regex-uc=/^(COMMENT: This is not working, although it does if we put it in the JS rules and set ft=javascript! O_o)/\1/X,XXX/
--regex-uc=/\<state\>[ \t]+([a-zA-Z_$][0-9a-zA-Z_$]*).*$/\1/s,state/

--langdef=coffee
--langmap=coffee:.coffee
--regex-coffee=/^(COMMENT: some of the .*s in below functions are over-optimistic, picking up anonymous callbacks with the wrong =)/\1/X,XXX/
--regex-coffee=/^class @?([a-zA-Z_$][0-9a-zA-Z_$]*)( extends [a-zA-Z_$][0-9a-zA-Z_$]*)?$/\1/c,class/
--regex-coffee=/^(COMMENT: The second case (this|@) is not an export when inside a method, it's just a property assignment. [ \t]*(@|this\.)([a-zA-Z_$][0-9a-zA-Z_$]*)[ \t]*=.*)$/\2/e,export/
--regex-coffee=/^[ \t]*(module\.exports\.)([a-zA-Z_$][0-9a-zA-Z_$]*)[ \t]*=.*$/\2/e,export/
--regex-coffee=/^[ \t]*(@[.]*|this\.)([a-zA-Z_$][0-9a-zA-Z_$]*)[ \t]*=.*$/\2/a,assigned/
--regex-coffee=/^(COMMENT: Choose one of the following rules, but not both, or you will generate duplicate tags!  1. all properties, 2. only function properties.  TODO: We might be able to fudge the property regexp to ignore functions (with or without arguments) so we can keep both rules at once.)/\1/X,XXX/
--regex-coffee=/^DISABLED: [ \t]*([a-zA-Z_$][0-9a-zA-Z_$]*):[^:]/\1/p,property/
--regex-coffee=/^[ \t]*([a-zA-Z_$][0-9a-zA-Z_$]*):[ \t]*(\([^(]*\)[ \t]*|[ \t]*)[-=]>.*$/\1/f,function/
--regex-coffee=/^[ \t]*([a-zA-Z_$][0-9a-zA-Z_$.:]*)[ \t]*=.*[-=]>.*$/\1/f,function/
--regex-coffee=/^[ \t]*([a-zA-Z_$][0-9a-zA-Z_$]*)[ \t]*=[^->\n]*$/\1/v,variable/

--langmap=Asm:+.spp
--regex-Asm=/^[^;]*\.macro[ \t]+([a-zA-Z_$][0-9a-zA-Z_$]*)/\1/m,macro/
--regex-Asm=/^[^;]*\.context[ \t]+([a-zA-Z_$][0-9a-zA-Z_$]*)/\1/c,context/
--regex-Asm=/^([A-Za-z0-9_]+):/\1/l,label/

--langdef=dosini
--langmap=dosini:.ini
--regex-dosini=/^\[([^]]*)\]/\1/s,section/

--langdef=haxe
--langmap=haxe:.hx
--regex-haxe=/^package[ \t]+([A-Za-z0-9_.]+)/\1/p,package/
--regex-haxe=/^[ \t]*[(@:macro|private|public|static|override|inline|dynamic)( \t)]*function[ \t]+([A-Za-z0-9_]+)/\1/f,function/
--regex-haxe=/^[ \t]*([private|public|static|protected|inline][ \t]*)+var[ \t]+([A-Za-z0-9_]+)/\2/v,variable/
--regex-haxe=/^[ \t]*package[ \t]*([A-Za-z0-9_]+)/\1/p,package/
--regex-haxe=/^[ \t]*(extern[ \t]*|@:native\([^)]*\)[ \t]*)*class[ \t]+([A-Za-z0-9_]+)[ \t]*[^\{]*/\2/c,class/
--regex-haxe=/^[ \t]*(extern[ \t]+)?interface[ \t]+([A-Za-z0-9_]+)/\2/i,interface/
--regex-haxe=/^[ \t]*typedef[ \t]+([A-Za-z0-9_]+)/\1/t,typedef/
--regex-haxe=/^[ \t]*enum[ \t]+([A-Za-z0-9_]+)/\1/t,typedef/
--regex-haxe=/^[ \t]*([A-Za-z0-9_]+)(;|\([^)]*:[^)]*\))/\1/t,enum_field/

--langdef=haxe-sws
--langmap=haxe-sws:.hx.sws
--regex-haxe-sws=/^package[ \t]+([A-Za-z0-9_.]+)/\1/p,package/
--regex-haxe-sws=/^[ \t]*[(@:macro|private|public|static|override|inline|dynamic)( \t)]*function[ \t]+([A-Za-z0-9_]+)/\1/f,function/
--regex-haxe-sws=/^[ \t]*([private|public|static|protected|inline][ \t]*)+var[ \t]+([A-Za-z0-9_]+)/\2/v,variable/
--regex-haxe-sws=/^[ \t]*package[ \t]*([A-Za-z0-9_]+)/\1/p,package/
--regex-haxe-sws=/^[ \t]*(extern[ \t]*|@:native\([^)]*\)[ \t]*)*class[ \t]+([A-Za-z0-9_]+)[ \t]*[^\{]*/\2/c,class/
--regex-haxe-sws=/^[ \t]*(extern[ \t]+)?interface[ \t]+([A-Za-z0-9_]+)/\2/i,interface/
--regex-haxe-sws=/^[ \t]*typedef[ \t]+([A-Za-z0-9_]+)/\1/t,typedef/
--regex-haxe-sws=/^[ \t]*enum[ \t]+([A-Za-z0-9_]+)/\1/t,typedef/
--regex-haxe-sws=/^[ \t]*([A-Za-z0-9_]+)(;|\([^)]*:[^)]*\))/\1/t,enum_field/

--langdef=joeygrammar
--langmap=joeygrammar:.grm
--regex-joeygrammar=/^[ \t]*([A-Za-z0-9_$@]*)[ \t]*=/\1/r,rule/

--langdef=haskell
--langmap=haskell:.hs
--regex-haskell=/^(COMMENT: matching = may miss functions declared with pattern matching, however those will tend to throw up multiple results which will be annoying.  We could seek :: but these are optional - the favourite probably depends on the style of the file you are editing.)/\1/X,XXX/
--regex-haskell=/^([a-zA-Z_][a-zA-Z0-9_]*)[ \t]*::.*/\1/s,signature/
--regex-haskell=/^(WARNING: Patterns can produce multiple entries, and this regexp also accidentally catches data and type lines too!)/\1/X,XXX/
--regex-haskell=/^data ([a-zA-Z_][a-zA-Z0-9_]*)/\1/d,data/
--regex-haskell=/^type ([a-zA-Z_][a-zA-Z0-9_]*)/\1/t,type/
--regex-haskell=/^([a-zA-Z_][a-zA-Z0-9_]*)[ \t]*=.*/\1/f,function/
--regex-haskell=/^([a-zA-Z_][a-zA-Z0-9_]*)[ \t]+[^=:].*=/\1/p,pattern/
--regex-haskell=/^(COMMENT: Argh, we could just go for signature and other (anything with =)!)/\1/X,XXX/
--regex-haskell=/^DISABLED: ([a-zA-Z_][a-zA-Z0-9_]*)[ \t]+[^=:].*=/\1/d,definition/
--regex-haskell=/^(COMMENT: Probably what we really want is one entry (the top one) instead of multiple pattern entries.)/\1/X,XXX/

--langdef=mkd
--langmap=mkd:.md
--regex-mkd=/^(#[^#].*)/\1/1,level1/
--regex-mkd=/^(##[^#].*)/\1/2,level2/
--regex-mkd=/^(###[^#].{0,19})/\1/3,level3/
--regex-mkd=/^(=[^=].*)/\1/1,level1/
--regex-mkd=/^(==[^=].*)/\1/2,level2/
--regex-mkd=/^(===[^=].{0,19})/\1/3,level3/

--langdef=help
--langmap=help:.txt
--regex-help=/^([0-9]+\. [A-Z].*)\*$/\1/s,section/
--regex-help=/^DISABLED: ([A-Z][A-Za-z0-9 ]*).*\*.+\*$/\1/h,heading/
--regex-help=/^([A-Z][A-Za-z0-9 ]*)[ \t]+\*.+\*/\1/h,heading/
--regex-help=/[\*]([^* \t]+)[\*]$/\1/m,marker/

--langdef=Scala
--langmap=Scala:.scala
--regex-Scala=/^[ \t]*class[ \t]*([a-zA-Z0-9_]+)/\1/c,class/
--regex-Scala=/^[ \t]*object[ \t]*([a-zA-Z0-9_]+)/\1/o,object/
--regex-Scala=/^[ \t]*trait[ \t]*([a-zA-Z0-9_]+)/\1/t,trait/
--regex-Scala=/^[ \t]*case[ \t]*class[ \t]*([a-zA-Z0-9_]+)/\1/r,cclass/
--regex-Scala=/^[ \t]*abstract[ \t]*class[ \t]*([a-zA-Z0-9_]+)/\1/a,aclass/
--regex-Scala=/^[ \t]*((private|override)[ \t]+)*def[ \t]*([a-zA-Z0-9_=]+)[ \t]*.*[:=]/\1/m,method/
--regex-Scala=/[ \t]*val[ \t]*([a-zA-Z0-9_]+)[ \t]*[:=]/\1/V,value/
--regex-Scala=/[ \t]*var[ \t]*([a-zA-Z0-9_]+)[ \t]*[:=]/\1/v,variable/
--regex-Scala=/^[ \t]*type[ \t]*([a-zA-Z0-9_]+)[ \t]*[\[<>=]/\1/T,type/
--regex-Scala=/^[ \t]*import[ \t]*([a-zA-Z0-9_{}., \t=>]+$)/\1/i,include/
--regex-Scala=/^[ \t]*package[ \t]*([a-zA-Z0-9_.]+$)/\1/p,package/

--langmap=html:+.erb
--regex-html=/^(COMMENT: Meteor)/\1/X,XXX/
--regex-html=/^[ \t]*<template[ \t]+name=["']([^"']*)./\1/t,template/
--regex-html=/^(COMMENT: Derby)/\1/X,XXX/
--regex-html=/^[ \t]*<([A-Za-z0-9\-_$]*):>/\1/t,template/
--regex-html=/\<id=["']([^"']*)./\1/i,id/

--langdef=scss
--langmap=scss:.scss
--regex-scss=/^[ \t]*@mixin ([A-Za-z0-9_-]+)/\1/m,mixin,mixins/
--regex-scss=/^[ \t]*\$([A-Za-z0-9_-]+)/\1/v,variable,variables/
--regex-scss=/^([A-Za-z0-9_-]*)*(\.[A-Za-z0-9_-]+) *[,{]/\2/c,class,classes/
--regex-scss=/^[ \t]+(\.[A-Za-z0-9_-]+) *[,{]/\1/c,class,classes/
--regex-scss=/^(.*)*\#([A-Za-z0-9_-]+) *[,{]/\2/i,id,ids/
--regex-scss=/^[ \t]*#([A-Za-z0-9_-]+)/\1/i,id,ids/
--regex-scss=/(^([A-Za-z0-9_-])*([A-Za-z0-9_-]+)) *[,|\{]/\1/t,tag,tags/
--regex-scss=/(^([^\/\/])*)[ \t]+([A-Za-z0-9_-]+)) *[,|\{]/\3/t,tag,tags/
--regex-scss=/(^(.*, *)([A-Za-z0-9_-]+)) *[,|\{]/\3/t,tag,tags/
--regex-scss=/(^[ \t]+([A-Za-z0-9_-]+)) *[,|\{]/\1/t,tag,tags/
--regex-scss=/^[ \t]*@media[ \t]+([A-Za-z0-9_-]+)/\1/d,media,media/

