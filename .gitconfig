# .gitconfig



# Essential to avoid warnings
[user]
	name = Paul "Joey" Clark
	email = joey@neuralyte.org



# Many of the following come from http://cheat.errtheblog.com/s/git

# Add colors
# Here 'white' is actually darker than the default!
[color]
	ui = auto
[color "branch"]
	current = green bold reverse   # default = green
	local = yellow   # default = white
	remote = red     # default = red
[color "diff"]
	# Commit messages and author will be pure white; I cannot find a place to configure them.
	# The commit id will be:
	commit = yellow bold reverse
	meta = cyan bold
	frag = magenta
	# Believe it or not, 'white' is a little bit darker than ffffff.  Put 'white' here to get a very light grey :-p
	func = white
	plain = white
	old = red bold
	new = green bold
[color "status"]
	branch = green bold reverse
	added = yellow
	changed = green
	untracked = cyan

# Highlight whitespace in diffs
[color]
	ui = true
[color "diff"]
	# Unfortunately this only shows for *added* lines, not for *removed* lines.  At time of writing, git had no way of doing that.  http://stackoverflow.com/questions/5257553/coloring-white-space-in-git-diffs-output
	whitespace = blue reverse



# May not be for everyone!  Actually does some stuff!
# TODO: Look up what the hell this does and document it!
[core]
	#whitespace=fix,-indent-with-non-tab,trailing-space,cr-at-eol
	excludesfile = /home/joey/.gitignore.global
	# Wrap lines when reading diffs
	# This sometimes drops the top of the log off the top of the screen, which is annoying
	#pager = less -r



# Aliases
[alias]
	st = status
	ci = commit
	br = branch
	co = checkout
	df = diff
	dc = diff --cached
	# Adds file summaries to the standard log
	lf = log --stat
	# Adds actual diffs to the standard log
	lg = log -p -m
	# Summaries (without/with branches?)
	#lol = log --graph --decorate --pretty=oneline --abbrev-commit
	lol = log --graph --pretty=format:'%C(yellow)%h%C(magenta bold)%d%C(reset) %s %C(cyan)- %an (%ar)%Creset'
	lola = log --graph --decorate --pretty=oneline --abbrev-commit --all
	prettylog = log --graph --full-history --all --color --pretty=format:"%x1b[31m%h%x09%x1b[32m%d%x1b[0m%x20%s"
	ls = ls-files
	# Show files ignored by git:
	ign = ls-files -o -i --exclude-standard
	ll = log -U0 -p -m
	ld = log -p --word-diff=plain -m
	# -p shows diffs.  -m shows diffs for merges

	# Joey's:
	# Just a list of the files that have changed on the origin (I hope)
	# You need to do a 'fetch' beforehand but not a 'merge'
	#newfiles = ls-files -u
	#newfiles = diff-files --stat
	# This shows change-counts in local files (and perhaps also what is new on the origin)
	# It can be used to show what files will change when you go git merge FETCH_HEAD
	# BUT note that it shows the *opposite* of what the merge will perform!
	# I.e. additions are red, removals are green!  :P
	whatsnewOrigin = diff-index --color --stat origin
	# Hmmm.  If no origin is set yes in .git/config, then we need to do this:
	# This shows only what is new on the origin (log and diffs!)
	# BUT ofc it only works after git fetch!
	#preview  = diff -p HEAD..origin
	#preview  = log -p HEAD..origin
	#preview  = log -p HEAD..origin/master
	#preview  = log -p HEAD..FETCH_HEAD
	preview = diff-index --color --stat FETCH_HEAD
	previewdiff = diff HEAD..FETCH_HEAD
	#whatsnew = log --stat HEAD..FETCH_HEAD
	whatsnew = log --graph --pretty=format:'%C(yellow bold reverse)%h%C(reset)%C(magenta bold)%d%C(black bold) %s %C(cyan)- %an (%ar)%Creset%n' --stat HEAD..FETCH_HEAD

	# Just shows the number of commits by each user
	whodidwhat = shortlog -nsw -e

	recent = diff HEAD~~~

	# List the aliases we have
	alias = !git config --list | grep 'alias\\.' | sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1\\\t = \\2/' | sort

	# This does not work on a branch, since origin = origin/master.
	#whatisnotpushed = log origin..HEAD --pretty=oneline
	# So use @{u} = upstream instead
	#whatisnotpushed = log @{u}..HEAD --pretty=oneline
	#whatisnotpushed = log HEAD@{u}..HEAD --pretty=oneline
	# or perhaps just compare against FETCH_HEAD?  That is prone to failure if we switch branch.
	whatisnotpushed = log FETCH_HEAD..HEAD --pretty=oneline
	# The following does not work sometimes ("warning: refname 'origin/master' is ambiguous.")  And it's useless if we are not on the master branch.  (It is more like whatisnotmergedintomaster.  You can see the number of different commits when switching between branches with git checkout.)
	#whatisnotpushed2 = log origin/master..HEAD --pretty=oneline
	# As an alternative, you can read the "ahead" count on the second line of git status

	# Compare two branches; commits on one branch that are not reachable from another:
	#   git log branchA ^branchB
	# More examples here: http://gitref.org/inspect/

	# This simply runs whatever command you give it in the shell.
	# The advantage is that shell aliases are always run in the root.
	# So for example, you can now do "git exec make" from any sub-folder of your project, to run make in the project's root folder.
	exec = "!exec "

	# Just a reminder for myself.  Instead of stashing uncommitted changes, you can bring them with you when you switch branch.
	checkout-carrying-unstashed-changes = checkout -m

	# You can use this to apply a stash pop to a dirty tree (to workaround the error "Cannot apply to a dirty working tree, please stage your changes").
	stash-pop-force = !git stash show -p | git apply && git stash drop



### The following options are rather more serious, because they affect how git modifies files.



# % git config core.autocrlf true
#
# autocrlf setting tells git to convert the newlines to the system's standard
# when checking out files, and to LF newlines when committing in
#
# I have this disabled for now, concerned about Beeb lookup tables and other binaries.
# [core]
	# autocrlf=true



# % git config branch.autosetupmerge true
#
# tells git-branch and git-checkout to setup new branches so that git-pull(1)
# will appropriately merge from that remote branch.  Recommended.  Without this,
# you will have to add --track to your branch command or manually merge remote
# tracking branches with "fetch" and then "merge".
#
# Disabled because I want git to be as difficult for me as for someone without my config.
#
#[branch]
#	autosetupmerge = true

# In a similar vein, this will make it so that pushes will go the same place that pulls come from:
#[push]
#	default=tracking



# To ignore whitespace
#
# % git config apply.whitespace nowarn
#
# I have this disabled because I use coffeescript, and in general I like
# whitespace to be meaningful!
#
#[apply]
#	whitespace = nowarn



## Of interest:
# http://stackoverflow.com/questions/849308/pull-push-from-multiple-remote-locations
# (elliot's answer: automatically push to two repositories)
# The basics of setting up a remote tracking branch:
# http://stackoverflow.com/questions/520650/how-do-you-make-an-existing-git-branch-track-a-remote-branch?rq=1


# Use vimdiff once each file to review diffs, by typing git difftool.
# One disadvantage is the ugliness of breaking out with Ctrl-C if you don't want to diff all the remaining files.
# Without this, you may be presented with other options:
#   Other options are available: merge tool candidates: opendiff kdiff3 tkdiff xxdiff meld kompare gvimdiff diffuse ecmerge p4merge araxis bc3 emerge vimdiff
[diff]
	tool = vimdiff
[difftool]
	prompt = false

