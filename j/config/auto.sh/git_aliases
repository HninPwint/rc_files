# What is useful in this file?
#
# Shortcuts:
#
#   gs ga gc gd gb gco and gm are simple aliases for git status, add, commit,
#   diff, branch, checkout and merge.  Use them to save yourself keystrokes.
#
#   gdc shows the "cached" diff of what is staged (what you are about to commit).
#
#   gll shows a log *overview*, with one commit per line.
#
#   gl is my favourite *detailed* log display, showing diffs, stats and commit
#   messages.  Keys n and N jump forwards/backwords through diffs.
#
#   Both gl and gll show the graph.
#
# Useful tools (the really good stuff!):
#
#   gbs [-M] [.] is "git branch status", a nice way to see which branches are
#   up-to-date with the remote (which need a push, pull or merge).
#
#   gbd [-M] [-r] is "git branch by date", a nice way to see which branches
#   were recently updated.  -r shows remote branches.
#
#   The -M argument to the above commands is slower, but will display whether
#   or not each branch has been merged into the current branch.  Cool!
#
#   They will only align neatly into columns if you have jsh's columnise-clever
#   installed.  Making that work independently is something I should TODO!
#
# I hope these shortcuts and tools will be of use to you.
#
# The other aliases and functions in this file I rarely use (except those which
# are required by the aliases of course).
#
# Some of the functions (gbs, gbd) do not work on Mac OSX / FreeBSD because I
# don't know how to get BSD sed to do search-replace.  However if you have
# installed the GNU coreutils package (e.g. via Homebrew) and GNU sed is on
# the *front* of your path, then they should work fine.

# TODO: Turn the aliases into shellscripts so they are available from vim's command line?
#       Put them somewhere and load them onto the PATH optionally.  (Not everyone will want them.)

# I had problems declaring functions whose name matched pre-existing aliases.  In my case this was when I was loading oh-my-zsh's git plugin before this script was sourced.
# Details: The function name was getting expanded into the alias during the declaration, either causing the declaration to fail syntactically, or to successfully silently declare the function using a different name!
# The behaviour I desired was to override his aliases with my own functions, but keep any of his aliases which did not conflict.
# The most sensible way to avoid expansion is to declare functions explicitly using `function name()` but some older shells do not recognize the `function` syntax, and I would like to support them.
# Another way to avoid expansion is to declare functions using `'name'()` instead of just `name()`.  This worked for zsh but not for bash.
# So finally I had to specifically unalias any function names which I *know* may be alaised elsewhere.
# This is all rather irrelevant now because I am no longer loading oh-my-zsh's git aliases.
unalias gs 2>/dev/null
unalias gd 2>/dev/null
unalias gitlog 2>/dev/null
unalias gac 2>/dev/null
unalias gitwhatsup 2>/dev/null
# Should I be doing this *everywhere* I declare a shell function in jsh, just in case an alias exists?!  No ... I just shouldn't load aliases I don't want!  :P
# By the way, if you want to do the same for a function, this works for bash and zsh:
#   unset -f fn_name

#alias gs='git status'
#alias gs='gitstatus'
#alias gs='if [ -t 1 ]; then gitstatus | more; else git status; fi'
#function gs() {
#	if [ -t 1 ]
#	then gitstatus "$@" | more
#	else git status "$@"
#	fi
#}
gs() {
	# Show color if not piping.  Skip to next section on 'n'.  Leave output on screen with -X (so user can copy paste).
	# Using more instead of less because on short output, less fills the rest of the screen with '~'s (or ''s) we don't need.  Those lines are actually caused by the search.  git's default 'pager' will do the same iff the +/ is added.
	# More has slightly different searching behaviour than less: it will not skip to the start of a section which is already visible on the screen.
	# This now rather equivalent to the default, except for the default search.
	if [ -t 1 ]
	then
		git -c color.status=always status "$@" |
		#more
		# On Mac, more cannot handle color.  Unless it is given -R.  But Linux more does not recognise that argument!  :P
		# I think the disadvantage with less might be when the output is lesser than the screen height, then more will just display those few lines and quit, but less will occupy the entire screen.  Also, does less destroy scrollback, while more preserves it?
		less -R -E -X
		# But can we use the more-like options for less below on Mac?
                # Hmmm that's not quite as neat: on short output, the bottom part of the screen is filled with empty lines.
		# The problem with doing this search with more is that more skips the first "branch" line, even though it is a match.  And it does not even allow paging up to find it!
		#more +'/^# [^ ].*'
		#less -R +'/^# [^ ].*' -E -X --tilde
		#pager -R +'/^# [^ ].*' -E -X --tilde
	else git status "$@"
	fi
}

#alias gd='git diff'
gd() {
	# Show color if not piping.  Skip to next file on 'n'.
	if [ -t 1 ]
	then git -c color.diff=always diff "$@" | less -R +'/^diff.*' -X
	else git diff "$@"
	fi
}
# Git Diff Words
alias gdw='git diff --word-diff=color'
# Git Diff Files
alias gdf='git diff --stat'
# Git Diff Staged / Cached (see which one I use most ... I used gdc!)
#alias gds='gdc'
alias gdc='gd --cached'

alias ga='git add'
#alias gc='git commit'
alias gc='git commit -v'
alias gf='git fetch'
alias gp='git preview'
alias gw='git whatsnew'
alias gm='git merge'

#alias gl='git log'
#alias gl='git log -U2 -p -m'
# I thought it might be nice to setup less so that we can jump to the next commit with 'n'
# Unfortunately whilst this provides the feature, git disables colors:
#   gl | less +"/^commit.*" -r
# Oh, fixed it.  Since this make paging commits very fast, now adding --stat
#alias gl='git -c color.ui=always log -U2 -p -m --stat | less -R "+/^commit.*"'
gitlog() {
	# Show color if not piping.  Skip to next file or commit on 'n'.
	if [ -t 1 ]
	then
		git -c color.ui=always log "$@" |
		#less -R +'/^(commit|diff).*' -X
		# Needed when using --graph and -p
		less -R +'/((^|\*[ |]*)commit .*|(^|\| +)diff --git.*)'
	else git log "$@"
	fi
	# BUG TODO: The --git may show as --combined when using gl -c, so change it for just -- after the pending merge.
}
# The regexp search allows us to quickly skip to the next diff or commit header by pressing `n`.  If you do not wish to jump through the diffs, you have two options:
#   1. Edit the search so it won't hit diff lines.  For example: `/<Left><Left><Left>z<Enter>`.  This will work for the rest of the session.
#   2. Count the number of files in this commit (as shown by --stat), add one, and jump that many times with e.g. `15n`.  This will work just once, so you can use `n` to skip diffs later.

# "Git Log Pure" - the basis for "Git Log Grey" but without colours
# I am not sure how useful -m is.  It shows us the diff of the merge *and* the individual commits from the merged branch, so we see some things twice.  We may want to remove it, or add --no-merges and/or --first-parent, so we can see the individual commits from merged branches, without the merge commits themselves (which would be duplicate information!).  The disadvantage is that by hiding merges, we don't see the correct moment at which the commit entered our local branch.  Perhaps we want to view the merges but not the commits from merged branches!  That is exactly the behaviour of --first-parent; then we should keep -m.  But then we can't see the log messages for those commits.
# So some sensible choices are: -m --first-parent to see the changes at merge time, or neither to see the log messages of individual commits.
# Probably the second is more desirable for gll, the first more desirable for glf or gld (gl).  Especially the first is useful because it shows us the fixed conflict files during a merge.  (So we can check that a merge has not snuck in unwanted code during the conflict resolution.)
# We could also try out --cc or -c options.
# Nah they didn't see helpful.  It's either -m --first-parent or neither.
# I think I originally added -m because I *thought* git log was not showing commit diffs from merged branches.  In fact it does, but it shows them individually, and leaves the merge commit itself empty.
# I am now finding this a little more informative than glg: git log -p --graph --decorate
# I rarely want to use glp directly; I prefer glg because it customizes the color of the commit message.
# OK so I recently had to track down some code which had been deleted/lost during a merge.  I was using git log <filename>.  The *only* way which worked was -c; -cc or neither would not display this line!  So -c all the way... at least for that case!  If -c causes duplicate information to be displayed, perhaps we should use it at the same time as not showing branches.
alias glp='gitlog -p -U2 --stat'
# Here --stat show a quick summary of changed files, before actually showing the diffs.  I rather enjoy this when using 'gl' as it lets me decide from the top of each commit whether there are any files I am interested in, and if not I can happily skip straight to the next commit.  In other situations, e.g. when I am planning to read all the details, --stat is just chaff.
# "Git Log Grey" - Like 'gl' except we present my favourite colors
# This is quite close to: git log --decorate -U2 -p -m --stat
# Curiously the alias shows fewer +++s and ---s on the stat output.
# One "advantage" of our custom format over --decorate is that --decorate shows different colors for different decorations.  Whilst this is nice and informative, it looks a little ugly when it combines with the reverse highlighting from our less search.
alias glg='glp --format=format:"%C(yellow bold)commit %H%C(magenta bold)%d%C(reset)%nAuthor: %an <%ae>%nDate:   %ad%n%n    %C(black bold)%s %C(reset)%C(yellow)%Creset%n"'
# Custom_format_bugs: Note that %b is missing (it should come after %s%n, it may show 'Conflicts' list or other useful notes).  But adding it conditionally is a hassle.
# "Git Log" aliases to "Git Log Grey"
#alias gl='glg'
# Now trying this out; use glm for old-ish style (merges merged) or use glg to see individual commits without the graph.
# We should probably swap glg and gl, since gl has a graph and glg does not!
# Interestingly this can show some commits in a different order from glg alone, in the presence of merges.
alias gl='glg --graph'
# glx is like gl but without my custom format colours and without my Custom_format_bugs.
alias glx='glp --graph'
# Warning: glg and glc duplicate my color settings.  (Which are also set in my ~/.gitconfig.)  Part of the reason I passed everything through glg/glc was to display decorations (commit labels like HEAD and origin/master).  I have since learned this can be achieved by passing --decorate, so we may be able to reduce some duplication that way.
# "Git Log with Merges-combined/merged)" - shows diffs in the merge, does not show individual commits from merged branches
alias glm='glg -m --first-parent'
# It seems to me that -c should be combined with --first-parent, to avoid seeing the same diffs twice (the final actual merge, as well as the commits on the branch)
# When -c is used, -m does nothing (at least in the example I tested)
# I did tests comparing `glg -c` against `glg -m`, and `glg -c --first-parent` against `glg -m --first-parent`.  Whilst -c did show the full diff of manual merges, it also excluded a lot of stuff!  Notably, merges with no conflicts.  (From the manual: "it lists only files which were modified from all parents").  So I don't see any way to see the true patched of manual merges (-c) without also excluding stuff.  Therefore, use -c only when you think you need it!  :P

# "Git Log Long" - One per line, with graph
#alias gll='git log --graph --decorate --pretty=oneline --abbrev-commit --all'   # Does not show committer's name or age of commit
#alias gll='git lol'
# Using the same colors as "Git Log Clear" except commits are not bold:
#alias gll='git log --graph --pretty=format:"%C(yellow)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'
# Problem: When used with --graph, glc should end in %n.  But we don't want the %n when --graph is not used (e.g. in glf below)!  I don't personally want the %n, but --graph always draws a |\n straight after the formatted text, so it looks messy without it.
alias gll='glc --graph'
# "Git Log Long Minus merges"
# This lists the merge commits themselves, but does not list any of the commits that were brought in by the merge.  This is useful if you have merged things into the current branch, but you are only interested in the commits that were actually made on the current branch.
# When using this, it can be nice to clearly distinguish merges from raw commits.  If your merge commit messages are pure, you can search /Merge.* or cleaner /Merge.* into [^ ]*
# gllm | highlight -bold -reverse "Merge.* into [^ ]*" magenta | more
if which highlight >/dev/null
then
	# Better because it allows arguments to be passed.  Breaks because glc is not loaded yet?
	#gllm() {
		#gll -m --first-parent "$@" |highlight -bold "Merge.*" blue | less -REX
	#}
	alias gllm='gll -m --first-parent | highlight -bold "Merge.*" blue | less -REX'
else alias gllm='gll -m --first-parent'
fi
# This shows the commits from merged branches (/), but not the merge commits themselves (\).  It takes less space than gll.
alias gllmm='gll --no-merges'
# Git Log Long No Graph
alias gllng='glc'
alias glls='gll --stat'

# "Git Log Clear" - Single lines, no graph.  Shows more info than: git log --pretty=oneline
# If you want to use this with --stat and --graph then it should have a %n at the end.  But this will make --graph show blank lines even when run without --stat.  Since glf does not use --graph, we don't really need this.
alias glc='git log --pretty=format:"%C(yellow bold)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'

# "Git Log Word-diffed" - It is debatable whether we want to page through diffs or just whole commits; it kinda depends what the user is looking for that particular time!
alias glw='gl --word-diff=color'
# "Git Log Stats/Summary" - Just file stats, no diffs.  BUG: Not grey, because glg uses glp which does -p (diffs)!
alias gls='gitlog --stat'
# "Git Log Files" - Compressed version of "Git Log Stats"
alias glf='glc --stat'
# With glf, we can walk commmits with /^[^ ]+
# Just commit info, one per line

alias gb='git branch'

# Git Branch by Date
git_branch_by_date() {
	local reset_color=`tput sgr0`
	# Optional
	local subject_color=`tput setaf 0 ; tput bold`
	local author_color=`tput setaf 6`

	local target=refs/heads
	#local commit_color=`git config --get-color color.diff.commit yellow`
	if [ "$1" = -r ]
	then
		target=refs/remotes/origin
		#branch_color=`git config --get-color color.branch.remote red`
	fi

	# %(committerdate:iso8601)
	git for-each-ref --sort=committerdate $target --format="%(refname:short) ${author_color}%(committerdate:relative) (%(authorname)) -${reset_color} ${subject_color}%(subject)${reset_color}"
}

# Git Branch by Date wrapper
gbd() {
	local reset_color=`tput sgr0`
	local current_branch_color=`git config --get-color color.branch.current green`
	local branch_color=`git config --get-color color.branch.local white`

	# TODO: Parse args in no particular order, and show help, like gbs does

	# We show two pages of history by default, or all of history if showancestors is unset
	local count='9999999'
	local count=$((LINES-2))
	local showancestors=''
	if [ "$1" = "-M" ]
	then showancestors="yes" ; shift
	fi
	if [ "$1" = "-n" ]
	then count="$2"; shift; shift
	fi

	local need_pager=
	if [ $count -gt $((LINES-2)) ]
	then need_pager=1
	fi

	current_branch=`git_get_current_branch`

	git_branch_by_date "$@" |
	tail -n "${count}" |
	while read refname rest
	do

        local local="${refname}"
        ## NOTE: This code is cloned from gbs.  Can we refactor it out?
        if [ "$local" = "$current_branch" ]
        then preBranch="* "
        else
            preBranch=". "
            if [ -n "$showancestors" ]
            then
                local_branch_commit_hash=`git rev-parse --verify "$local"`
                common_commit_between_branch_and_current=`git merge-base "$local" "$current_branch"`
                if [ "$common_commit_between_branch_and_current" = "$local_branch_commit_hash" ]
                then preBranch="| "
                else preBranch="/ "
                fi
                # I considered using "+" and "-" instead, but these are harder to visually distinguish from "*" and each other.
                # Another alternative I tried was "~" and "x", but again the "*" is easily lost there.
            fi
        fi

		echo "${preBranch}${refname} ${rest}"
	done |

	if which columnise-clever >/dev/null
	then columnise-clever -ignore '[^ ]* *[^ ]* *[^ ]*'
	else cat
	fi |
	replace_ancestor_markers_with_colors |
	if [ -n "$need_pager" ]
	then
		# -R=show_colors -X=no_clear -S=chop_long_lines +G=jump_to_end
		less -R -X -S +G
		#more -R   (since more=less on Mac; fails on Linux)
	else
		# -E=quit_at_end (in other words this just chops long lines)
		less -R -E -X -S +G
		#cat
	fi
}

# Git View Branches (tree-like)
alias gvb='git log --oneline --decorate --graph --simplify-by-decoration'
# For remotes too, add: --all
# Could also be Git View Tree or Git Tree View, although I might want to save those for gitv!  :P

unalias gco 2>/dev/null   # REMOVEME
#alias gco='git checkout'
gco() {
	git checkout "$@"
	if [ -n "$POST_GIT_CHECKOUT" ]
	then "$POST_GIT_CHECKOUT" "$@"
	fi
}
POST_GIT_CHECKOUT=post_git_checkout
post_git_checkout() {
	if which cindex >/dev/null
	then
		local git_root_folder=$(git rev-parse --show-toplevel)
		# If any of the indexed folders are equal to or below this project's folder
		if [ -n "$git_root_folder" ] && cindex -list | grep -q "^$git_root_folder\($\|/\)"
		then
			echo -n "Updating cindex..." >&2
			cindex 2>/dev/null
			echo >&2
		fi
	fi
}
alias gi='git commit --interactive'
# -p "patch"? allows us to choose which hunks to add or commit
alias gap='git add -p'
alias gcp='git commit -p'

# Git auto commit OR Git-add-commit
gac() {
	git add "$@"
	echo -n "Commit message: "
	read msg
	git commit -m "$msg"
}

# May rename "gitsummary"
gitwhatsup() {
	echo
	# Absolute path:
	local gitDir=$(git rev-parse --show-toplevel)/.git
	# On some systems, gives relative path:
	#local gitDir=$(git rev-parse --git-dir)
	local greenBackground=$(tput setab 2)
	local whiteForeground=$(tput setaf 7)
	#echo "${greenBackground}${whiteForeground}$(cursebold)GITDIR:$(tput init) $gitDir"
	echo "`cursecyan`=== Git directory ===`cursenorm`"
	echo "$gitDir"
	echo
	#echo "`cursecyan`$gitDir`cursenorm`"
	#echo "${greenBackground}${whiteForeground}$(cursebold)$gitDir$(tput init)"
	echo "`cursecyan`=== Remotes ===`cursenorm`"
	git remote -v #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Local branches ===`cursenorm`"
	git branch -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Remote branches ===`cursenorm`"
	git branch -r -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Not yet pushed ===`cursenorm`"
	gll "@{u}..HEAD" | cat
	echo
	echo
	# Try `git remote update` if you can't see all the remote branches
}
alias gwu=gitwhatsup

# Guesses the name of the upstream branch, given the local branch name (or no arguments, which assumes current branch)
git_guess_upstream_branch() {
	local local_branch remote_branch remote_commit
	# No problem if this arg is empty, it will work fine for the current branch anyway
	local_branch="$1"
	# First guess
	remote_branch="$local_branch@{upstream}"
	# Check if it exists
	# We cannot use --symbolic or --abbrev-ref here; it will return what was given even if no upstream exists.
	# In fact we must specify --revs-only to prevent that from occurring!
	# We hide the error if the remote branch is not found.
	# BUG: On git 1.8.5.2 on MacOSX, we are getting remote_commit='a_long_hash_id'  I was hoping it would be empty, so we could at least guess a symbolic remote branch.
	remote_commit=$(git rev-parse --revs-only "$remote_branch" 2>/dev/null)
	if [ -z "$remote_commit" ]
	then
		# If no upstream was set, guess a branch on "origin" with the same name.  TODO: if "origin" does not exist, can we make a better guess?
		# Before we can do that, we may need a name for the local branch, if none was provided
		if [ -z "$local_branch" ]
		then local_branch=$(git_get_current_branch)
		fi
		remote_branch="origin/$local_branch"
		# Check if it exists (we could have probably done this the same way we used earlier)
		if ! git branch --list -r "$remote_branch" | grep . >/dev/null
		then remote_branch=""
		fi
	fi
	echo "$remote_branch"
}

# Git What Is Not Pushed (doesn't always work - I use gbs more often)
#alias gwinp='gll @{upstream}..HEAD'
alias gwinp='gll $(git_guess_upstream_branch)..HEAD'
# Git What Is Not Pushed Details
alias gwinpd='gl $(git_guess_upstream_branch)..HEAD'
# Git To Push
alias gtp='gwinp'
# Git To Push Files
alias gtpf='git topush'
# Git To Push Log
alias gtpl='gwinpd'
# Git To Push Details / Diff (a direct diff, without listing each commit)
alias gtpd='gd FETCH_HEAD..HEAD'

# Git Merge Origin (this branch)
#alias gmo='verbosely git merge $(git_guess_upstream_branch)'
alias gmo='verbosely git merge origin/$(git_get_current_branch)'
# Git Push Origin (this branch)
alias gpo='verbosely git push origin $(git_get_current_branch)'

git_branch_status() {
    # Original: https://gist.github.com/Mark-Booth/5058384
    # This version by Joeytwiddle

    # Displays your git branches with a summary of how many commits ahead or behind the local is from its remote branch.
    # Also displays (through color/labels) which branches are ancestors of (have already been merged into) the current branch.

    # If no upstream is set for a branch, it will guess a branch with the same name on origin.
    # Use the 'gbs' alias wrapper below for colors and column alignment.

    # example:
    # $ git branch-status -a
    # dns_check (ahead 1) | (behind 112) origin/master
    # master (ahead 2) | (behind 0) origin/master
    # $ git branch-status
    # master (ahead 2) | (behind 0) origin/master

    # Surely this was a non-local variable leaking out of git_branch_status and has already been fixed.
    # BUG (fixed?): Running gbs after git_branch_status -a -v gives only 1-line output.  Steps to reproduce:
    # Use Mac.  Start jsh in bash (with GNU coreutils etc.).  See gbs works fine.  Now do git_branch_status -a -v, also works fine.
    # Now see gbs only displays one line!
    # From initial tracing, it appeared that the final gbs call only iterates once during the while getopts.
    # Since we need both -v and -a to show more than one line here, we saw only one line.

    local usage option filter OPTARG compareto showancestors verbose current_branch local remote DELTAS LEFT_AHEAD RIGHT_AHEAD preBranch

    local local_branch_commit_hash common_commit_between_branch_and_current

    local sorting=

    usage="$(basename "$0") [-hamtMv] -- summarise status of branch(es)

where:
    -h           show this help text
    -a           show all branches, not just the current one
    -m           shows branch(es) with respect to origin/master
    -t <branch>  shows branch(es) with respect to given branch
    -d           sort by date (default is to sort by name)
    -M           indicates branches which have been merged into current
    -v           verbose, show output even if counts are zero"

    while getopts 'hamt:pdMv' option; do
      case "$option" in
        h) echo "$usage"
           exit
           ;;
        a) filter=refs/heads
           ;;
        m) compareto=origin/master
           ;;
        t) compareto="$OPTARG"
           ;;
        d) sorting="--sort=committerdate"
           ;;
        M) showancestors=true
           ;;
        v) verbose=true
           ;;
        ?) printf "illegal option: '%s'\n" "$OPTARG" >&2
           echo "$usage" >&2
           exit 1
           ;;
      esac
    done
    shift $((OPTIND - 1))

    if [ -z $filter ] ; then
        filter=$(git symbolic-ref -q HEAD)
    fi

    current_branch=`git_get_current_branch`

    git for-each-ref $sorting --format="%(refname:short) %(upstream:short)" $filter | \
    while read local remote
    do
        if [ -n "$compareto" ] ; then
            remote="$compareto"
        fi
        #[ -z "$remote" ] && continue
        # This is an assumption I made for our project - that if a branch does not have an upstream set, then we should assume the upstream is a branch on 'origin' with the same name.
        # It could be avoided if we used --track when initially creating the local branch with git branch or git checkout.  Tracking can also be setup retrospectively with `git branch -u <remote_branch>` in Git > 1.8.0 or `git branch --set-upstream <local_branch> <remote_branch>` in Git > 1.7.0.
        if [ -z "$remote" ]
        then
            # If no upstream has been set, assume a remote branch with the same name
            remote="origin/$local"
            if ! git branch --list -r "$remote" | grep . >/dev/null
            then
                # No remote branch exists
                remote=""
                # But if this is the current branch, or we are in verbose mode, we might still like to display it anyway.
                # However ahead/behind counts are meaningless without a remote.
                if [ "$local" = "$current_branch" ] || [ -n "$verbose" ]
                then :
                else continue
                fi
            fi
        fi
        # If we do not have a remote to compare to, display no counts, rather than relative to current branch, which is quite arbitrary (but can be achieved using $compareto if desired).
        if [ -n "$remote" ]
        then DELTAS=$(git rev-list --left-right ${local}...${remote})
        else DELTAS=""
        fi
        LEFT_AHEAD=$(echo "$DELTAS" | grep -c '^<')
        RIGHT_AHEAD=$(echo "$DELTAS" | grep -c '^>')

        if [ "$local" = "$current_branch" ]
        then preBranch="* "
        else
            preBranch=". "
            if [ -n "$showancestors" ]
            then
                local_branch_commit_hash=`git rev-parse --verify "$local"`
                common_commit_between_branch_and_current=`git merge-base "$local" "$current_branch"`
                if [ "$common_commit_between_branch_and_current" = "$local_branch_commit_hash" ]
                then preBranch="| "
                else preBranch="/ "
                fi
                # I considered using "+" and "-" instead, but these are harder to visually distinguish from "*" and each other.
                # Another alternative I tried was "~" and "x", but again the "*" is easily lost there.
            fi
        fi

        if [ $verbose ] || [ $LEFT_AHEAD -gt 0 ] || [ $RIGHT_AHEAD -gt 0 ] || [ "$local" = "$current_branch" ] ; then
            #echo "$local $WARN_LEFT(ahead $LEFT_AHEAD)$reset_color | $WARN_RIGHT(behind $RIGHT_AHEAD)$reset_color $remote"
            echo "$preBranch$local $if_merged(ahead $LEFT_AHEAD) | (behind $RIGHT_AHEAD) $remote"
        fi
    done
}
gbs() {
  # A wrapper for git_branch_status that adds color.
  # Displays status of current branch relative to upstream and downstream versions
  # With no arguments, inspects all branches
  # With argument `.`, displays current branch
  # With any other argument, uses that as the branch name
  # If the branch has no upstream (pull) specified, then assume origin/<branch_name> if it exists, otherwise assume origin/master
  # If the branch has no downstream (push) specified, then assume origin/<branch_name>
  # This may help: http://stackoverflow.com/questions/2969214/git-programmatically-know-by-how-much-the-branch-is-ahead-behind-a-remote-branc
  # git branch -v can partially do this already.  It shows e.g. [behind 12] after the commit hash but before the message.  Unfortunately it has no color and does not stand out very well.
  # Or perhaps better: https://gist.github.com/jehiah/1288596 (from http://stackoverflow.com/questions/7773939/show-git-ahead-and-behind-info-for-all-branches-including-remotes )

  local show_color
  local color_setting=`git config --get color.ui`
  if [ "$color_setting" = 'true' ] || [ "$color_setting" = 'auto' ] && [ -t 1 ]
  then show_color=true
  fi

  if [ "$1" = . ]
  then shift ; git_branch_status "$@"
  else git_branch_status -a -v "$@"
  fi |
  column -s ' ' -t | sed 's+ \( *\)+\1+g' |
  #columnise |
  if [ -n "$show_color" ]
  then
    # We should probably only do this jazz if $() = 'true' or = 'auto' && [ -t 1 ]
    local reset_color=`tput sgr0`
    local ahead_color=`tput setaf 2 ; tput bold`    # green
    local behind_color=`tput setaf 1 ; tput bold`   # red
    # You can use the configured/default colors, but I quite like remote blank!  (The default red confuses behind_color.)
    # The default remote branch color is red, but that conflicts with behind_color, so I have set it to 'white' here.
    local remote_branch_color=`git config --get-color color.branch.remote white`
    sed "
      s+\()  *\)\([^ ]*\)$+\1$remote_branch_color\2$reset_color+
      s+(ahead *[1-9][0-9]*)+$ahead_color\0$reset_color+
      s+(behind *[1-9][0-9]*)+$behind_color\0$reset_color+
    " |
    replace_ancestor_markers_with_colors
  else cat
  fi
}

replace_ancestor_markers_with_colors() {
	local current_branch_color=`git config --get-color color.branch.current green`
	local local_branch_color=`git config --get-color color.branch.local white`
	local ancestor_branch_color=`git config --get-color color.branch.ancestor cyan`
	sed "
		s+^[*] *\([^ ]*\)+* $current_branch_color\1$reset_color+
		s+^[./x-] *\([^ ]*\)+  $local_branch_color\1$reset_color+
		s+^[\\+|] *\([^ ]*\)+  $ancestor_branch_color\1$reset_color+
	"
}

git_get_current_branch() {
	# symbolic-ref fails during an incomplete rebase with `fatal: ref HEAD is not a symbolic ref`
	git symbolic-ref --short HEAD
	# rev-parse does not fail, but responds with "HEAD" instead of the branch name.
	#git rev-parse --abbrev-ref HEAD
}

git_find_branch_start_commit() {
	local other_branch current_branch

	# It is more likely we want to compare the current branch against an alternative, than to compare an alternative against master.  So we accept the alternative first.
	if [ -n "$1" ]
	then other_branch="$1"
	else
		#other_branch=master
		#other_branch=origin/master
		# TODO: This is a hack for my current project.  It should be set as an option, not hard-coded in here.  E.g. GIT_MERGE_BASE_DEFAULT_OTHER_BRANCH_NAME
		other_branch=v3-master
	fi

	# But user may specify the "current" branch second if they wish
	if [ -n "$2" ]
	then current_branch="$2"
	else current_branch=`git_get_current_branch`
	fi
	# Although the order doesn't really matter when passing 2 arguments, since merge-base is symmetric!

	# This is not guaranteed, but the information is likely still in the cache if the branch was created in the last 90 days.
	# In fact it completely fails if you have pulled the branch from a remote repository.  It shows the HEAD at the time that you pulled!
	#git reflog show $current_branch | tail -n 1

	git merge-base "$other_branch" "$current_branch"
}

git_find_branch_start() {
	local commitId=`git_find_branch_start_commit`

	if [ -n "$commitId" ]
	then
		# These vars have disappeared inside the refactored function :P
		#echo "$current_branch and $other_branch share common commit:"
		#git log --pretty=oneline -1 "$commitId"
		glc -1 "$commitId"
	fi
}

# vim: ft=sh
