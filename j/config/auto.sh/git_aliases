# TODO: Turn these into shellscripts so they are available from vim's command line.
#       Put them somewhere and load them onto the PATH optionally.  (Not everyone will want them.)

# I had problems declaring functions whose name matched pre-existing aliases.  In my case this was when I was loading oh-my-zsh's git plugin before this script was sourced.
# Details: The function name was getting expanded into the alias during the declaration, either causing the declaration to fail syntactically, or to successfully silently declare the function using a different name!
# The behaviour I desired was to override his aliases with my own functions, but keep any of his aliases which did not conflict.
# The most sensible way to avoid expansion is to declare functions explicitly using `function name()` but some older shells do not recognize the `function` syntax, and I would like to support them.
# Another way to avoid expansion is to declare functions using `'name'()` instead of just `name()`.  This worked for zsh but not for bash.
# So finally I had to specifically unalias any function names which I *know* may be alaised elsewhere.
# This is all rather irrelevant now because I am no longer loading oh-my-zsh's git aliases.
unalias gs 2>/dev/null
unalias gd 2>/dev/null
unalias gitlog 2>/dev/null
unalias gac 2>/dev/null
unalias gitwhatsup 2>/dev/null
# Should I be doing this *everywhere* I declare a shell function in jsh, just in case an alias exists?!  No ... I just shouldn't load aliases I don't want!  :P

#alias gs='git status'
#alias gs='gitstatus'
#alias gs='if [ -t 1 ]; then gitstatus | more; else git status; fi'
#function gs() {
#	if [ -t 1 ]
#	then gitstatus "$@" | more
#	else git status "$@"
#	fi
#}
gs() {
	# Show color if not piping.  Skip to next section on 'n'.  Leave output on screen with -X (so user can copy paste).
	# Using more instead of less because on short output, less fills the rest of the screen with '~'s (or ''s) we don't need.  Those lines are actually caused by the search.  git's default 'pager' will do the same iff the +/ is added.
	# More has slightly different searching behaviour than less: it will not skip to the start of a section which is already visible on the screen.
	# This now rather equivalent to the default, except for the default search.
	if [ -t 1 ]
	then
		git -c color.status=always status "$@" |
		more
		# The problem with doing this search with more is that more skips the first "branch" line, even though it is a match.  And it does not even allow paging up to find it!
		#more +'/^# [^ ].*'
		#less -R +'/^# [^ ].*' -E -X --tilde
		#pager -R +'/^# [^ ].*' -E -X --tilde
	else git status "$@"
	fi
}

#alias gd='git diff'
gd() {
	# Show color if not piping.  Skip to next file on 'n'.
	if [ -t 1 ]
	then git -c color.diff=always diff "$@" | less -R +'/^diff.*' -X
	else git diff "$@"
	fi
}
# Git Diff Words
alias gdw='git diff --word-diff=color'
# Git Diff Files
alias gdf='git diff --stat'
# Git Diff Staged / Cached (see which one I use most ... I used gdc!)
#alias gds='gdc'
alias gdc='gd --cached'

alias ga='git add'
#alias gc='git commit'
alias gc='git commit -v'
alias gf='git fetch'
alias gp='git preview'
alias gw='git whatsnew'
alias gm='git merge FETCH_HEAD'

#alias gl='git log'
#alias gl='git log -U2 -p -m'
# I thought it might be nice to setup less so that we can jump to the next commit with 'n'
# Unfortunately whilst this provides the feature, git disables colors:
#   gl | less +"/^commit.*" -r
# Oh, fixed it.  Since this make paging commits very fast, now adding --stat
#alias gl='git -c color.ui=always log -U2 -p -m --stat | less -R "+/^commit.*"'
gitlog() {
	# Show color if not piping.  Skip to next file or commit on 'n'.
	if [ -t 1 ]
	then
		git -c color.ui=always log "$@" |
		#less -R +'/^(commit|diff).*' -X
		# Needed when using --graph and -p
		less -R +'/((^|\*[ |]*)commit .*|(^|\| )diff --git.*)'
	else git log "$@"
	fi
}
# The regexp search allows us to quickly skip to the next diff or commit header by pressing `n`.  If you do not wish to jump through the diffs, you have two options:
#   1. Edit the search so it won't hit diff lines.  For example: `/<Left><Left><Left>z<Enter>`.  This will work for the rest of the session.
#   2. Count the number of files in this commit (as shown by --stat), add one, and jump that many times with e.g. `15n`.  This will work just once, so you can use `n` to skip diffs later.

# "Git Log Pure" - the basis for "Git Log Grey" but without colours
# I am not sure how useful -m is.  It shows us the diff of the merge *and* the individual commits from the merged branch, so we see some things twice.  We may want to remove it, or add --no-merges and/or --first-parent, so we can see the individual commits from merged branches, without the merge commits themselves (which would be duplicate information!).  The disadvantage is that by hiding merges, we don't see the correct moment at which the commit entered our local branch.  Perhaps we want to view the merges but not the commits from merged branches!  That is exactly the behaviour of --first-parent; then we should keep -m.  But then we can't see the log messages for those commits.
# So some sensible choices are: -m --first-parent to see the changes at merge time, or neither to see the log messages of individual commits.
# Probably the second is more desirable for gll, the first more desirable for glf or gld (gl).  Especially the first is useful because it shows us the fixed conflict files during a merge.  (So we can check that a merge has not snuck in unwanted code during the conflict resolution.)
# We could also try out --cc or -c options.
# Nah they didn't see helpful.  It's either -m --first-parent or neither.
# I think I originally added -m because I *thought* git log was not showing commit diffs from merged branches.  In fact it does, but it shows them individually, and leaves the merge commit itself empty.
# I am now finding this a little more informative than glg: git log -p --graph --decorate
# I rarely want to use glp directly; I prefer glg because it customizes the color of the commit message.
alias glp='gitlog -p -U2 --stat'
# Here --stat show a quick summary of changed files, before actually showing the diffs.  I rather enjoy this when using 'gl' as it lets me decide from the top of each commit whether there are any files I am interested in, and if not I can happily skip straight to the next commit.  In other situations, e.g. when I am planning to read all the details, --stat is just chaff.
# "Git Log Grey" - Like 'gl' except we present my favourite colors
# This is quite close to: git log --decorate -U2 -p -m --stat
# Curiously the alias shows fewer +++s and ---s on the stat output.
# One "advantage" of our custom formate over --decorate is that --decorate shows different colors for different decorations.  Whilst this is nice and informative, it looks a little ugly when it combines with the reverse highlighting from our less search.
alias glg='glp --format=format:"%C(yellow bold)commit %H%C(magenta bold)%d%C(reset)%nAuthor: %an %ae%nDate:   %ad%n%n    %C(black bold)%s %C(reset)%C(yellow)%Creset%n"'
# "Git Log" aliases to "Git Log Grey"
#alias gl='glg'
# Now trying this out; use glm for old-ish style (merges merged) or use glg to see individual commits without the graph.
# We should probably swap glg and gl, since gl has a graph and glg does not!
alias gl='glg --graph'
# Warning: glg and glc duplicate my color settings.  (Which are also set in my ~/.gitconfig.)  Part of the reason I passed everything through glg/glc was to display decorations (commit labels like HEAD and origin/master).  I have since learned this can be achieved by passing --decorate, so we may be able to reduce some duplication that way.
# "Git Log with Merges-combined/merged)" - shows diffs in the merge, does not show individual commits from merged branches
alias glm='glg -m --first-parent'

# "Git Log Long" - One per line, with graph
#alias gll='git log --graph --decorate --pretty=oneline --abbrev-commit --all'   # Does not show committer's name or age of commit
#alias gll='git lol'
# Using the same colors as "Git Log Clear" except commits are not bold:
#alias gll='git log --graph --pretty=format:"%C(yellow)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'
alias gll='glc --graph'
# "Git Log Long Minus merges"
alias gllm='gll --no-merges'

# "Git Log Clear" - Single lines, no graph.  Shows more info than: git log --pretty=oneline
# If you want to use this with --stat and --graph then it should have a %n at the end.  But this will make --graph show blank lines even when run without --stat.  Since glf does not use --graph, we don't really need this.
alias glc='git log --pretty=format:"%C(yellow bold)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'

# "Git Log Word-diffed" - It is debatable whether we want to page through diffs or just whole commits; it kinda depends what the user is looking for that particular time!
alias glw='gl --word-diff=color'
# "Git Log Stats/Summary" - Just file stats, no diffs.
alias gls='gl --stat'
# "Git Log Files" - Compressed version of "Git Log Stats"
alias glf='glc --stat'
# With glf, we can walk commmits with /^[^ ]+
# Just commit info, one per line

alias gb='git branch'
alias gco='git checkout'
alias gi='git commit --interactive'

# Git auto commit OR Git-add-commit
gac() {
	git add "$@"
	echo -n "Commit message: "
	read msg
	git commit -m "$msg"
}

# May rename "gitsummary"
gitwhatsup() {
	echo
	# Absolute path:
	local gitDir=$(git rev-parse --show-toplevel)/.git
	# On some systems, gives relative path:
	#local gitDir=$(git rev-parse --git-dir)
	local greenBackground=$(tput setab 2)
	local whiteForeground=$(tput setaf 7)
	#echo "${greenBackground}${whiteForeground}$(cursebold)GITDIR:$(tput init) $gitDir"
	echo "`cursecyan`=== Git directory ===`cursenorm`"
	echo "$gitDir"
	echo
	#echo "`cursecyan`$gitDir`cursenorm`"
	#echo "${greenBackground}${whiteForeground}$(cursebold)$gitDir$(tput init)"
	echo "`cursecyan`=== Remotes ===`cursenorm`"
	git remote -v #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Local branches ===`cursenorm`"
	git branch -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Remote branches ===`cursenorm`"
	git branch -r -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Not yet pushed ===`cursenorm`"
	gll "@{u}..HEAD" | cat
	echo
	echo
	# Try `git remote update` if you can't see all the remote branches
}
alias gwu=gitwhatsup

# Git What Is Not Pushed
alias gwinp='gll FETCH_HEAD..HEAD'
# Git What Is Not Pushed Details
alias gwinpd='gl FETCH_HEAD..HEAD'
# Git To Push
alias gtp='gwinp'
# Git To Push Files
alias gtpf='git topush'
# Git To Push Log
alias gtpl='gwinpd'
# Git To Push Details / Diff (a direct diff, without listing each commit)
alias gtpd='gd FETCH_HEAD..HEAD'

git_branch_status() {
    # hosted at   https://gist.github.com/Mark-Booth/5058384
    # forked from https://gist.github.com/lth2h/4177524 @ ae184f1 by mark.booth
    # forked from https://gist.github.com/jehiah/1288596 @ e357c1e by lth2h
    # ideas from https://github.com/kortina/bakpak/blob/master/bin/git-branches-vs-origin-master

    # this prints out some branch status
    # (similar to the '... ahead' info you get from git status)

    # example:
    # $ git branch-status -a
    # dns_check (ahead 1) | (behind 112) origin/master
    # master (ahead 2) | (behind 0) origin/master
    # $ git branch-status
    # master (ahead 2) | (behind 0) origin/master

    local usage option filter OPTARG compareto verbose current_branch local remote DELTAS LEFT_AHEAD RIGHT_AHEAD preBranch

    local gbs_show_if_merged local_branch_commit_hash common_commit_between_branch_and_current

    gbs_show_if_merged=yes

    usage="$(basename "$0") [-hav] -- summarise status of branch(es)

where:
    -h           show this help text
    -a           show all branches, not just the current one
    -m           shows branch(es) with respect to origin/master
    -t <branch>  shows branch(es) with respect to given branch
    -v           verbose, show output even if counts are zero"

    while getopts 'hamt:v' option; do
      case "$option" in
        h) echo "$usage"
           exit
           ;;
        a) filter=refs/heads
           ;;
        m) compareto=origin/master
           ;;
        t) compareto="$OPTARG"
           ;;
        v) verbose=true
           ;;
        ?) printf "illegal option: '%s'\n" "$OPTARG" >&2
           echo "$usage" >&2
           exit 1
           ;;
      esac
    done
    shift $((OPTIND - 1))

    if [ -z $filter ] ; then
        filter=$(git symbolic-ref -q HEAD)
    fi

    current_branch=`git_get_branch_name`

    git for-each-ref --format="%(refname:short) %(upstream:short)" $filter | \
    while read local remote
    do
        if [ -n "$compareto" ] ; then
            remote="$compareto"
        fi
        #[ -z "$remote" ] && continue
        # This is an assumption I made for our project - that if a branch does not have an upstream set, then we should assume the upstream is a branch on 'origin' with the same name.
        # It could be avoided if we used --track when initially creating the local branch with git branch or git checkout.  Tracking can also be setup retrospectively with `git branch -u <remote_branch>` in Git > 1.8.0 or `git branch --set-upstream <local_branch> <remote_branch>` in Git > 1.7.0.
        if [ -z "$remote" ]
        then
            # If no upstream has been set, assume a remote branch with the same name
            remote="origin/$local"
            if ! git branch --list -r "$remote" | grep . >/dev/null
            then
                # No remote branch exists
                remote=""
                # But if this is the current branch, or we are in verbose mode, we might still like to display it anyway.
                # However ahead/behind counts are meaningless without a remote.
                if [ "$local" = "$current_branch" ] || [ -n "$verbose" ]
                then :
                else continue
                fi
            fi
        fi
        # If we do not have a remote to compare to, display no counts, rather than relative to current branch, which is quite arbitrary (but can be achieved using $compareto if desired).
        if [ -n "$remote" ]
        then DELTAS=$(git rev-list --left-right ${local}...${remote})
        else DELTAS=""
        fi
        LEFT_AHEAD=$(echo "$DELTAS" | grep -c '^<')
        RIGHT_AHEAD=$(echo "$DELTAS" | grep -c '^>')
        if [ "$local" = "$current_branch" ]
        then preBranch="* "
        else
            preBranch=". "
            if [ -n "$gbs_show_if_merged" ]
            then
                local_branch_commit_hash=`git rev-parse --verify "$local"`
                common_commit_between_branch_and_current=`git merge-base "$local" "$current_branch"`
                if [ "$common_commit_between_branch_and_current" = "$local_branch_commit_hash" ]
                then preBranch="~ "
                else preBranch="x "
                fi
            fi
        fi
        if [ $verbose ] || [ $LEFT_AHEAD -gt 0 ] || [ $RIGHT_AHEAD -gt 0 ] || [ "$local" = "$current_branch" ] ; then
            #echo "$local $WARN_LEFT(ahead $LEFT_AHEAD)$reset_color | $WARN_RIGHT(behind $RIGHT_AHEAD)$reset_color $remote"
            echo "$preBranch$local $if_merged(ahead $LEFT_AHEAD) | (behind $RIGHT_AHEAD) $remote"
        fi
    done
}
gbs() {
  # A wrapper for git_branch_status that adds color.
  # Displays status of current branch relative to upstream and downstream versions
  # With no arguments, inspects all branches
  # With argument `.`, displays current branch
  # With any other argument, uses that as the branch name
  # If the branch has no upstream (pull) specified, then assume origin/<branch_name> if it exists, otherwise assume origin/master
  # If the branch has no downstream (push) specified, then assume origin/<branch_name>
  # This may help: http://stackoverflow.com/questions/2969214/git-programmatically-know-by-how-much-the-branch-is-ahead-behind-a-remote-branc
  # git branch -v can partially do this already.  It shows e.g. [behind 12] after the commit hash but before the message.  Unfortunately it has no color and does not stand out very well.
  # Or perhaps better: https://gist.github.com/jehiah/1288596 (from http://stackoverflow.com/questions/7773939/show-git-ahead-and-behind-info-for-all-branches-including-remotes )

  local reset_color=`tput sgr0`
  local ahead_color=`tput setaf 2 ; tput bold`
  local behind_color=`tput setaf 1 ; tput bold`
  # You can use the configured/default colors, but I quite like remote blank!  (The default red confuses behind_color.)
  local current_branch_color=`git config --get-color color.branch.current green`
  # I don't think anyone really wants color.  If you do, uncomment these:
  local local_branch_color=`git config --get-color color.branch.local white`
  #local remote_branch_color=`git config --get-color color.branch.remote red`
  local merged_branch_color=`git config --get-color color.branch.already_merged green`

  if [ "$1" = . ]
  then shift ; git_branch_status "$@"
  else git_branch_status -a -v "$@"
  fi |
  column -s ' ' -t | sed 's+ \( *\)+\1+g' |
  #columnise |
  #highlight -bold "(ahead *[1-9][0-9]*)" green |
  #highlight -bold "(behind *[1-9][0-9]*)" red |
  sed "
    s+(ahead *[1-9][0-9]*)+$ahead_color\0$reset_color+
    s+(behind *[1-9][0-9]*)+$behind_color\0$reset_color+
    s+^[*] *\([^ ]*\)+* $current_branch_color\1$reset_color+
    s+^[.x] *\([^ ]*\)+  $local_branch_color\1$reset_color+
    s+^[~] *\([^ ]*\)+  $merged_branch_color\1$reset_color+
    s+[^ ]*$+$remote_branch_color\0$reset_color+
  "
}

git_get_branch_name() {
	git rev-parse --abbrev-ref HEAD
}

git_find_branch_start_commit() {
	local other_branch current_branch

	# It is more likely we want to compare the current branch against an alternative, than to compare an alternative against master.  So we accept the alternative first.
	if [ -n "$1" ]
	then other_branch="$1"
	else
		#other_branch=master
		#other_branch=origin/master
		#other_branch=v3-alpha-stable
		other_branch=v3-master
	fi

	# But user may specify the "current" branch second if they wish
	if [ -n "$2" ]
	then current_branch="$2"
	else current_branch=`git_get_branch_name`
	fi
	# Although the order doesn't really matter when passing 2 arguments, since merge-base is symmetric!

	# This is not guaranteed, but the information is likely still in the cache if the branch was created in the last 90 days.
	# In fact it completely fails if you have pulled the branch from a remote repository.  It shows the HEAD at the time that you pulled!
	#git reflog show $current_branch | tail -n 1

	git merge-base "$other_branch" "$current_branch"
}

git_find_branch_start() {
	local commitId=`git_find_branch_start_commit`

	if [ -n "$commitId" ]
	then
		echo "$current_branch and $other_branch share common commit:"
		#git log --pretty=oneline -1 "$commitId"
		glc -1 "$commitId"
	fi
}

